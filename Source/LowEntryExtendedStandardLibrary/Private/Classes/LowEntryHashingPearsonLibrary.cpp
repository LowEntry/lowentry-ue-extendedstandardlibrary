// Copyright Low Entry. Apache License, Version 2.0.

#include "LowEntryHashingPearsonLibrary.h"


const uint8 ULowEntryHashingPearsonLibrary::pearson[256] = {(uint8) 0x62, (uint8) 0x06, (uint8) 0x55, (uint8) 0x96, (uint8) 0x24, (uint8) 0x17, (uint8) 0x70, (uint8) 0xA4, (uint8) 0x87, (uint8) 0xCF, (uint8) 0xA9, (uint8) 0x05, (uint8) 0x1A, (uint8) 0x40, (uint8) 0xA5, (uint8) 0xDB, (uint8) 0x3D, (uint8) 0x14, (uint8) 0x44, (uint8) 0x59, (uint8) 0x82, (uint8) 0x3F, (uint8) 0x34, (uint8) 0x66, (uint8) 0x18, (uint8) 0xE5, (uint8) 0x84, (uint8) 0xF5, (uint8) 0x50, (uint8) 0xD8, (uint8) 0xC3, (uint8) 0x73, (uint8) 0x5A, (uint8) 0xA8, (uint8) 0x9C, (uint8) 0xCB, (uint8) 0xB1, (uint8) 0x78, (uint8) 0x02, (uint8) 0xBE, (uint8) 0xBC, (uint8) 0x07, (uint8) 0x64, (uint8) 0xB9, (uint8) 0xAE, (uint8) 0xF3, (uint8) 0xA2, (uint8) 0x0A, (uint8) 0xED, (uint8) 0x12, (uint8) 0xFD, (uint8) 0xE1, (uint8) 0x08, (uint8) 0xD0, (uint8) 0xAC, (uint8) 0xF4, (uint8) 0xFF, (uint8) 0x7E, (uint8) 0x65, (uint8) 0x4F, (uint8) 0x91, (uint8) 0xEB, (uint8) 0xE4, (uint8) 0x79, (uint8) 0x7B, (uint8) 0xFB, (uint8) 0x43, (uint8) 0xFA, (uint8) 0xA1, (uint8) 0x00, (uint8) 0x6B, (uint8) 0x61, (uint8) 0xF1, (uint8) 0x6F, (uint8) 0xB5, (uint8) 0x52, (uint8) 0xF9, (uint8) 0x21, (uint8) 0x45, (uint8) 0x37, (uint8) 0x3B, (uint8) 0x99, (uint8) 0x1D, (uint8) 0x09, (uint8) 0xD5, (uint8) 0xA7, (uint8) 0x54, (uint8) 0x5D, (uint8) 0x1E, (uint8) 0x2E, (uint8) 0x5E, (uint8) 0x4B, (uint8) 0x97, (uint8) 0x72, (uint8) 0x49, (uint8) 0xDE, (uint8) 0xC5, (uint8) 0x60, (uint8) 0xD2, (uint8) 0x2D, (uint8) 0x10, (uint8) 0xE3, (uint8) 0xF8, (uint8) 0xCA, (uint8) 0x33, (uint8) 0x98, (uint8) 0xFC, (uint8) 0x7D, (uint8) 0x51, (uint8) 0xCE, (uint8) 0xD7, (uint8) 0xBA, (uint8) 0x27, (uint8) 0x9E, (uint8) 0xB2, (uint8) 0xBB, (uint8) 0x83, (uint8) 0x88, (uint8) 0x01, (uint8) 0x31, (uint8) 0x32, (uint8) 0x11, (uint8) 0x8D, (uint8) 0x5B, (uint8) 0x2F, (uint8) 0x81, (uint8) 0x3C, (uint8) 0x63, (uint8) 0x9A, (uint8) 0x23, (uint8) 0x56, (uint8) 0xAB, (uint8) 0x69, (uint8) 0x22, (uint8) 0x26, (uint8) 0xC8, (uint8) 0x93, (uint8) 0x3A, (uint8) 0x4D, (uint8) 0x76, (uint8) 0xAD, (uint8) 0xF6, (uint8) 0x4C, (uint8) 0xFE, (uint8) 0x85, (uint8) 0xE8, (uint8) 0xC4, (uint8) 0x90, (uint8) 0xC6, (uint8) 0x7C, (uint8) 0x35, (uint8) 0x04, (uint8) 0x6C, (uint8) 0x4A, (uint8) 0xDF, (uint8) 0xEA, (uint8) 0x86, (uint8) 0xE6, (uint8) 0x9D, (uint8) 0x8B, (uint8) 0xBD, (uint8) 0xCD, (uint8) 0xC7, (uint8) 0x80, (uint8) 0xB0, (uint8) 0x13, (uint8) 0xD3, (uint8) 0xEC, (uint8) 0x7F, (uint8) 0xC0, (uint8) 0xE7, (uint8) 0x46, (uint8) 0xE9, (uint8) 0x58, (uint8) 0x92, (uint8) 0x2C, (uint8) 0xB7, (uint8) 0xC9, (uint8) 0x16, (uint8) 0x53, (uint8) 0x0D, (uint8) 0xD6, (uint8) 0x74, (uint8) 0x6D, (uint8) 0x9F, (uint8) 0x20, (uint8) 0x5F, (uint8) 0xE2, (uint8) 0x8C, (uint8) 0xDC, (uint8) 0x39, (uint8) 0x0C, (uint8) 0xDD, (uint8) 0x1F, (uint8) 0xD1, (uint8) 0xB6, (uint8) 0x8F, (uint8) 0x5C, (uint8) 0x95, (uint8) 0xB8, (uint8) 0x94, (uint8) 0x3E, (uint8) 0x71, (uint8) 0x41, (uint8) 0x25, (uint8) 0x1B, (uint8) 0x6A, (uint8) 0xA6, (uint8) 0x03, (uint8) 0x0E, (uint8) 0xCC, (uint8) 0x48, (uint8) 0x15, (uint8) 0x29, (uint8) 0x38, (uint8) 0x42, (uint8) 0x1C, (uint8) 0xC1, (uint8) 0x28, (uint8) 0xD9, (uint8) 0x19, (uint8) 0x36, (uint8) 0xB3, (uint8) 0x75, (uint8) 0xEE, (uint8) 0x57, (uint8) 0xF0, (uint8) 0x9B, (uint8) 0xB4, (uint8) 0xAA, (uint8) 0xF2, (uint8) 0xD4, (uint8) 0xBF, (uint8) 0xA3, (uint8) 0x4E, (uint8) 0xDA, (uint8) 0x89, (uint8) 0xC2, (uint8) 0xAF, (uint8) 0x6E, (uint8) 0x2B, (uint8) 0x77, (uint8) 0xE0, (uint8) 0x47, (uint8) 0x7A, (uint8) 0x8E, (uint8) 0x2A, (uint8) 0xA0, (uint8) 0x68, (uint8) 0x30, (uint8) 0xF7, (uint8) 0x67, (uint8) 0x0F, (uint8) 0x0B, (uint8) 0x8A, (uint8) 0xEF};


TArray<uint8> ULowEntryHashingPearsonLibrary::Hash(const TArray<uint8>& Bytes, int32 Index, int32 Length, const int32 HashLength)
{
	if(HashLength <= 0)
	{
		return TArray<uint8>();
	}

	TArray<uint8> hh;
	hh.SetNum(HashLength);

	if(Bytes.Num() <= 0)
	{
		return hh;
	}

	if(Index < 0)
	{
		Length += Index;
		Index = 0;
	}
	if(Length >(Bytes.Num() - Index))
	{
		Length = Bytes.Num() - Index;
	}
	if(Length <= 0)
	{
		return hh;
	}

	for(int32 j = 0; j < HashLength; j++)
	{
		uint8 h = pearson[((Bytes[Index] + j) & 0xff) % 256];
		for(int32 i = 1; i < Length; i++)
		{
			h = pearson[(h ^ Bytes[(Index + i) & 0xff]) & 0xff];
		}
		hh[j] = h;
	}
	return hh;
}
